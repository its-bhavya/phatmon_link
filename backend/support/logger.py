"""
Support Interaction Logger for Support Bot.

This module provides logging capabilities for support bot interactions,
including support activations, crisis detections, and bot conversations.
All sensitive content is anonymized using SHA-256 hashing for privacy protection.

Requirements: 8.1, 8.2, 8.3, 8.4, 8.5
"""

import hashlib
import json
import logging
from datetime import datetime
from typing import Optional
from sqlalchemy.orm import Session

from backend.database import SupportActivation, CrisisDetection, SupportInteraction
from backend.support.sentiment import SentimentResult, CrisisType

# Configure module logger
logger = logging.getLogger(__name__)


class SupportInteractionLogger:
    """
    Logger for support bot interactions.
    
    Responsibilities:
    - Log support activations
    - Log crisis detections
    - Anonymize sensitive content
    - Track effectiveness metrics
    
    Requirements: 8.1, 8.2, 8.3, 8.4, 8.5
    """
    
    def __init__(self, db: Session):
        """
        Initialize the support interaction logger.
        
        Args:
            db: Database session for logging operations
        """
        self.db = db
    
    def log_support_activation(
        self,
        user_id: int,
        sentiment: SentimentResult,
        trigger_message: str
    ) -> None:
        """
        Log when support bot is activated for a user.
        
        Args:
            user_id: ID of the user triggering support
            sentiment: SentimentResult from analysis
            trigger_message: Original message that triggered support
            
        Requirements: 8.1
        """
        try:
            # Anonymize the trigger message
            message_hash = self._anonymize_content(trigger_message)
            
            # Create activation record
            activation = SupportActivation(
                user_id=user_id,
                emotion_type=sentiment.emotion.value,
                intensity=sentiment.intensity,
                trigger_message_hash=message_hash,
                activated_at=datetime.utcnow()
            )
            
            self.db.add(activation)
            self.db.commit()
            
            logger.info(
                f"Support activated for user {user_id}: "
                f"emotion={sentiment.emotion.value}, intensity={sentiment.intensity:.2f}"
            )
            
        except Exception as e:
            logger.error(f"Failed to log support activation: {e}")
            self.db.rollback()
            # Continue operation - logging failures shouldn't block support
    
    def log_crisis_detection(
        self,
        user_id: int,
        crisis_type: CrisisType,
        message: str,
        hotlines_provided: Optional[list] = None
    ) -> None:
        """
        Log when a crisis situation is detected.
        
        Args:
            user_id: ID of the user in crisis
            crisis_type: Type of crisis detected
            message: Original message containing crisis indicators
            hotlines_provided: List of hotline names provided to user
            
        Requirements: 8.3
        """
        try:
            # Anonymize the message
            message_hash = self._anonymize_content(message)
            
            # Convert hotlines list to JSON
            hotlines_json = None
            if hotlines_provided:
                hotlines_json = json.dumps(hotlines_provided)
            
            # Create crisis detection record
            detection = CrisisDetection(
                user_id=user_id,
                crisis_type=crisis_type.value,
                message_hash=message_hash,
                hotlines_provided=hotlines_json,
                detected_at=datetime.utcnow()
            )
            
            self.db.add(detection)
            self.db.commit()
            
            logger.warning(
                f"Crisis detected for user {user_id}: "
                f"type={crisis_type.value}, hotlines={len(hotlines_provided or [])}"
            )
            
        except Exception as e:
            logger.error(f"Failed to log crisis detection: {e}")
            self.db.rollback()
            # Continue operation - logging failures shouldn't block support
    
    def log_bot_interaction(
        self,
        user_id: int,
        user_message: str,
        bot_response: str
    ) -> None:
        """
        Log a support bot interaction.
        
        Args:
            user_id: ID of the user interacting with bot
            user_message: Message sent by user
            bot_response: Response generated by bot
            
        Requirements: 8.4
        """
        try:
            # Anonymize both messages
            user_message_hash = self._anonymize_content(user_message)
            bot_response_hash = self._anonymize_content(bot_response)
            
            # Create interaction record
            interaction = SupportInteraction(
                user_id=user_id,
                user_message_hash=user_message_hash,
                bot_response_hash=bot_response_hash,
                interaction_at=datetime.utcnow()
            )
            
            self.db.add(interaction)
            self.db.commit()
            
            logger.debug(f"Bot interaction logged for user {user_id}")
            
        except Exception as e:
            logger.error(f"Failed to log bot interaction: {e}")
            self.db.rollback()
            # Continue operation - logging failures shouldn't block support
    
    def _anonymize_content(self, content: str) -> str:
        """
        Anonymize sensitive content for logging using SHA-256 hashing.
        
        Args:
            content: Content to anonymize
            
        Returns:
            SHA-256 hash of the content (hex string)
            
        Requirements: 8.5
        """
        if not content:
            return ""
        
        # Use SHA-256 for secure one-way hashing
        # This protects user privacy while allowing duplicate detection
        hash_object = hashlib.sha256(content.encode('utf-8'))
        return hash_object.hexdigest()
